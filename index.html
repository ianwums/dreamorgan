<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Misty Drone — Dream Organ (Feature Build v1.1)</title>
<style>
  :root { --bg:#0b0f14; --text:#e9f1f7; --muted:#94a3b8; --accent:#67d4ff; --accent2:#b486ff; --good:#69e089; --warn:#ffcc66; --bad:#ff6b6b; }
  html,body{height:100%;margin:0;background:
    radial-gradient(1200px 700px at 70% -10%, rgba(103,212,255,.06), transparent 60%),
    radial-gradient(900px 600px at -10% 120%, rgba(180,134,255,.07), transparent 60%),
    var(--bg); color:var(--text); font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; }
  .wrap{max-width:1100px;margin:24px auto;padding:16px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:16px;}
  h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.4px;}
  .pill{padding:6px 10px;border-radius:999px;background:linear-gradient(135deg,rgba(103,212,255,.18),rgba(180,134,255,.18));border:1px solid rgba(255,255,255,.12);color:var(--muted);font-size:12px;}
  .btn{appearance:none;border:0;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;color:#0b0f14;
       background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 10px 24px rgba(103,212,255,.25), inset 0 1px 0 rgba(255,255,255,.3);}
  .btn.secondary{background:rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.14); box-shadow:none;}
  .btn.toggled{outline:2px solid var(--accent); background:rgba(103,212,255,.16); color:var(--text);}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .state{font-size:12px;color:var(--muted);}
  .badge{padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06);}
  .ok{border-color:rgba(105,224,137,.4); background:rgba(105,224,137,.12);}
  .err{border-color:rgba(255,107,107,.4); background:rgba(255,107,107,.12);}
  .grid{display:grid;gap:16px;grid-template-columns:1.1fr 1fr;}
  @media (max-width:980px){.grid{grid-template-columns:1fr;}}
  .panel{padding:14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));}
  .panel h2{margin:0 0 10px;font-size:14px;color:var(--muted);letter-spacing:.3px;}
  .controls{display:grid;gap:10px;grid-template-columns:repeat(2,minmax(0,1fr));}
  .control{background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.06);padding:10px;border-radius:12px;}
  .control label{display:flex;justify-content:space-between;color:var(--muted);font-size:12px;margin-bottom:6px;}
  input[type="range"]{width:100%;accent-color:#7ed3ff;}
  .chip{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.07);border-radius:12px;padding:10px;}
  .note{font-size:26px;font-weight:700}
  #mist{width:100%;height:420px;border-radius:14px;display:block;background:#0b0f14;} /* solid dark base to avoid 'white box' */
  details.debug summary{cursor:pointer; color:var(--muted); user-select:none;}
  details.debug{margin-top:10px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row">
      <h1>Misty Drone</h1>
      <span class="pill">dreamy organ — feature build v1.1</span>
    </div>
    <div class="row">
      <button id="startBtn" class="btn">Start Audio</button>
      <label class="row" style="gap:6px;"><input id="fxOn" type="checkbox"><span class="state">FX On</span></label>
      <label class="row" style="gap:6px;"><input id="autoFollow" type="checkbox" checked><span class="state">Auto-Follow Mic</span></label>
      <label class="row" style="gap:6px;"><input id="h5" type="checkbox" checked><span class="state">+5th</span></label>
      <label class="row" style="gap:6px;"><input id="h9" type="checkbox"><span class="state">+9th</span></label>
      <!-- NEW: Freeze/Release -->
      <button id="freezeBtn" class="btn secondary" title="Hold current notes">Freeze</button>
      <button id="releaseBtn" class="btn secondary" title="Release held notes">Release</button>
    </div>
    <div class="row">
      <button id="enableMicBtn" class="btn secondary">Enable Mic</button>
      <span class="state">AudioContext: <span id="ctxState">—</span></span>
      <span id="micStatus" class="badge">Mic: —</span>
    </div>
  </header>

  <div class="grid">
    <section class="panel">
      <h2>Organ</h2>
      <div class="controls">
        <div class="control"><label>Master Volume <span id="volVal">0.80</span></label><input id="volume" type="range" min="0" max="1" step="0.01" value="0.80"/></div>
        <div class="control"><label>Attack <span id="attackVal">0.80s</span></label><input id="attack" type="range" min="0" max="3" step="0.01" value="0.80"/></div>
        <div class="control"><label>Release <span id="releaseVal">2.50s</span></label><input id="release" type="range" min="0.1" max="6" step="0.05" value="2.5"/></div>
        <div class="control"><label>Tone (LPF) <span id="toneVal">1800 Hz</span></label><input id="tone" type="range" min="300" max="6000" step="10" value="1800"/></div>
        <div class="control"><label>Chorus Width <span id="chorusVal">0.35</span></label><input id="chorus" type="range" min="0" max="1" step="0.01" value="0.35"/></div>
        <div class="control"><label>Reverb Mix <span id="reverbVal">0.25</span></label><input id="reverb" type="range" min="0" max="0.9" step="0.01" value="0.25"/></div>
      </div>
      <details class="debug">
        <summary>Debug tools</summary>
        <div class="row" style="margin-top:8px;">
          <button id="beepBtn" class="btn secondary">Beep 1s</button>
          <button id="testDirectBtn" class="btn secondary">Test Drone (Direct)</button>
          <button id="testOrganBtn" class="btn secondary">Test Drone (Organ Path)</button>
          <button id="panicBtn" class="btn secondary" title="kills voices">Panic</button>
        </div>
      </details>
    </section>

    <section class="panel">
      <h2>Mic & Detection</h2>
      <div class="controls">
        <div class="control"><label>Input Gain <span id="micGainVal">1.00</span></label><input id="micGain" type="range" min="0" max="3" step="0.01" value="1.0"/></div>
        <div class="control"><label>Preamp Boost <span id="preampVal">+0 dB</span></label><input id="preamp" type="range" min="0" max="30" step="1" value="0"/></div>
        <div class="control"><label>Input Gate <span id="gateVal">-60 dBFS</span></label><input id="gate" type="range" min="-90" max="-30" step="1" value="-60"/></div>
      </div>
      <div class="controls" style="grid-template-columns:1fr;">
        <div class="chip">
          <div class="row" style="justify-content:space-between"><div>Input Level</div><div id="inDb">mic off</div></div>
          <canvas id="inMeter" width="300" height="12" style="width:100%;height:12px;border-radius:8px;background:rgba(255,255,255,.05)"></canvas>
        </div>
        <div class="chip">
          <div>Dominant Pitch</div>
          <div class="note" id="noteName">—</div>
          <div id="hz" class="state">— Hz</div>
        </div>
      </div>
    </section>
  </div>

  <section class="panel" style="margin-top:16px">
    <h2>Visualizer</h2>
    <canvas id="mist" width="900" height="450"></canvas>
  </section>
</div>

<script>
(function(){
  // ===== Utilities =====
  const A4=440, NOTE_NAMES=["C","C♯","D","E♭","E","F","F♯","G","A♭","A","B♭","B"];
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const dbToGain=db=>Math.pow(10, db/20);
  const rmsToDbfs=rms=>20*Math.log10(rms || 1e-12);
  const noteNameOf=f=>{ if(!f||!isFinite(f)||f<=0) return "—"; const n=Math.round(12*Math.log2(f/A4))+69; return NOTE_NAMES[(n%12+12)%12]+(Math.floor(n/12)-1); };
  const LS_KEY='misty-drone-v1.1';

  // ===== DOM =====
  const $=id=>document.getElementById(id);
  const startBtn=$("startBtn"), enableMicBtn=$("enableMicBtn");
  const beepBtn=$("beepBtn"), testDirectBtn=$("testDirectBtn"), testOrganBtn=$("testOrganBtn"), panicBtn=$("panicBtn");
  const ctxStateEl=$("ctxState"), micStatusEl=$("micStatus");
  const volumeEl=$("volume"), attackEl=$("attack"), releaseEl=$("release"), toneEl=$("tone"), chorusEl=$("chorus"), reverbEl=$("reverb"), fxOnEl=$("fxOn");
  const volVal=$("volVal"), attackVal=$("attackVal"), releaseVal=$("releaseVal"), toneVal=$("toneVal"), chorusVal=$("chorusVal"), reverbVal=$("reverbVal");
  const micGainEl=$("micGain"), preampEl=$("preamp"), gateEl=$("gate"), micGainVal=$("micGainVal"), preampVal=$("preampVal"), gateVal=$("gateVal");
  const inMeter=$("inMeter"), mctx=inMeter.getContext("2d"), inDbEl=$("inDb");
  const noteEl=$("noteName"), hzEl=$("hz");
  const autoFollowEl=$("autoFollow"), h5El=$("h5"), h9El=$("h9");
  const freezeBtn=$("freezeBtn"), releaseBtn=$("releaseBtn");
  const canvas=$("mist"), vctx=canvas.getContext("2d");

  // ===== Audio state =====
  let audioCtx;
  // Organ path
  let envGain, outGain, limiter;
  let lpf, d1, d2, lfo1, lfo2, lfoG1, lfoG2, dryMix, revSend, convolver, revRet, revMix, fxOut;
  // Mic path
  let micStream, micSource, micGain, preamp, comp, analyser, timeData;
  // Analysis state
  let lastStableFreq=0, stableCount=0, envVis=0;
  // Voices
  let voices=[];

  // Freeze state
  let holdFrozen=false;
  let frozenTargets=[];

  // ===== Settings =====
  function saveSettings(){
    const data={
      volume:+volumeEl.value, attack:+attackEl.value, release:+releaseEl.value, tone:+toneEl.value,
      chorus:+chorusEl.value, reverb:+reverbEl.value, fxOn:fxOnEl.checked,
      micGain:+micGainEl.value, preamp:+preampEl.value, gate:+gateEl.value,
      autoFollow:autoFollowEl.checked, h5:h5El.checked, h9:h9El.checked
    };
    localStorage.setItem(LS_KEY, JSON.stringify(data));
  }
  function loadSettings(){
    try{
      const data=JSON.parse(localStorage.getItem(LS_KEY)||'{}');
      for (const [k,v] of Object.entries(data)){
        const el=({volume:volumeEl,attack:attackEl,release:releaseEl,tone:toneEl,chorus:chorusEl,reverb:reverbEl,
                   micGain:micGainEl,preamp:preampEl,gate:gateEl}[k]);
        if (el) el.value=v;
        if (k==='fxOn') fxOnEl.checked=v;
        if (k==='autoFollow') autoFollowEl.checked=v;
        if (k==='h5') h5El.checked=v;
        if (k==='h9') h9El.checked=v;
      }
    }catch{}
    volVal.textContent=(+volumeEl.value).toFixed(2);
    attackVal.textContent=(+attackEl.value).toFixed(2)+'s';
    releaseVal.textContent=(+releaseEl.value).toFixed(2)+'s';
    toneVal.textContent=Math.round(+toneEl.value)+' Hz';
    chorusVal.textContent=(+chorusEl.value).toFixed(2);
    reverbVal.textContent=(+reverbEl.value).toFixed(2);
    micGainVal.textContent=(+micGainEl.value).toFixed(2);
    preampVal.textContent=`+${(+preampEl.value).toFixed(0)} dB`;
    gateVal.textContent=`${(+gateEl.value).toFixed(0)} dBFS`;
  }
  loadSettings();

  // ===== Start Audio =====
  async function startAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)({ latencyHint:"interactive" });
    updateCtxState();

    // Core buses
    envGain = audioCtx.createGain(); envGain.gain.value=0.0001; // non-zero to avoid Safari ramp quirks
    outGain = audioCtx.createGain(); outGain.gain.value=parseFloat(volumeEl.value);

    // Output soft limiter
    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value=-3; limiter.knee.value=6; limiter.ratio.value=4; limiter.attack.value=0.003; limiter.release.value=0.25;

    // Simple path: env -> out -> limiter -> destination
    envGain.connect(outGain).connect(limiter).connect(audioCtx.destination);

    // FX path
    lpf = audioCtx.createBiquadFilter(); lpf.type="lowpass"; lpf.frequency.value=parseFloat(toneEl.value); lpf.Q.value=0.5;
    d1 = audioCtx.createDelay(); d2 = audioCtx.createDelay(); d1.delayTime.value=0.012; d2.delayTime.value=0.018;
    lfo1 = audioCtx.createOscillator(); lfo2 = audioCtx.createOscillator(); lfoG1 = audioCtx.createGain(); lfoG2 = audioCtx.createGain();
    lfo1.frequency.value=0.28; lfo2.frequency.value=0.41; lfoG1.gain.value=0.006; lfoG2.gain.value=0.008;
    lfo1.connect(lfoG1).connect(d1.delayTime); lfo2.connect(lfoG2).connect(d2.delayTime); lfo1.start(); lfo2.start();
    dryMix = audioCtx.createGain(); dryMix.gain.value=1.0;
    revSend = audioCtx.createGain(); revSend.gain.value=0.25;
    convolver = audioCtx.createConvolver(); convolver.buffer=buildIR(audioCtx,2.2,0.4);
    revRet = audioCtx.createGain(); revRet.gain.value=1.0;
    revMix = audioCtx.createGain(); revMix.gain.value=parseFloat(reverbEl.value);
    fxOut = audioCtx.createGain(); fxOut.gain.value=1.0;

    envGain.connect(lpf);
    lpf.connect(d1); lpf.connect(d2);
    d1.connect(dryMix); d2.connect(dryMix);
    dryMix.connect(revSend); revSend.connect(convolver); convolver.connect(revRet); revRet.connect(revMix);
    dryMix.connect(fxOut); revMix.connect(fxOut);
    fxOut.connect(outGain);

    setFxActive(fxOnEl.checked);

    // Kick visuals (draw loop already running; this just ensures audio-linked values exist)
  }

  function setFxActive(on){
    if (!audioCtx) return;
    fxOut.gain.setValueAtTime(on ? 1.0 : 0.0, audioCtx.currentTime);
  }

  // ===== Organ voices =====
  function makeVoice(freq){
    const osc1=audioCtx.createOscillator(), osc2=audioCtx.createOscillator();
    const vGain=audioCtx.createGain(); vGain.gain.value=0.0001;
    const vf=audioCtx.createBiquadFilter(); vf.type='lowpass'; vf.frequency.value=parseFloat(toneEl.value);
    const lfo=audioCtx.createOscillator(), lg=audioCtx.createGain();
    lfo.frequency.value=0.12+Math.random()*0.08; lg.gain.value=4+Math.random()*4; lfo.connect(lg).connect(osc2.detune);
    osc1.type='sawtooth'; osc2.type='triangle'; osc1.frequency.value=freq*0.995; osc2.frequency.value=freq*1.005;
    osc1.connect(vGain); osc2.connect(vGain); vGain.connect(vf).connect(envGain);
    const t=audioCtx.currentTime; osc1.start(t); osc2.start(t); lfo.start(t);
    const level = 0.25 / Math.sqrt(1 + voices.length);
    return {osc1,osc2,vGain,level,vf,freq,_used:true};
  }

  function openEnv(){
    const now=audioCtx?.currentTime||0;
    envGain.gain.cancelScheduledValues(now);
    envGain.gain.setValueAtTime(Math.max(envGain.gain.value, 0.0001), now);
    envGain.gain.setTargetAtTime(1.0, now, Math.max(0.02, parseFloat(attackEl.value))*0.6);
  }
  function closeEnv(){
    const now=audioCtx?.currentTime||0;
    envGain.gain.cancelScheduledValues(now);
    envGain.gain.setValueAtTime(Math.max(envGain.gain.value, 0.0001), now);
    envGain.gain.setTargetAtTime(0.0, now, Math.max(0.04, parseFloat(releaseEl.value))*0.6);
  }

  function setDrone(freqs){
    if (!audioCtx) return;
    const now=audioCtx.currentTime;
    voices.forEach(v=>v._used=false);

    freqs.forEach(f=>{
      let v=voices.find(v=>Math.abs(v.freq - f) < 0.5);
      if(!v){ v=makeVoice(f); voices.push(v); }
      v._used=true; v.freq=f;
      v.osc1.frequency.setValueAtTime(f*0.995, now);
      v.osc2.frequency.setValueAtTime(f*1.005, now);
      v.vGain.gain.cancelScheduledValues(now);
      v.vGain.gain.setValueAtTime(Math.max(v.vGain.gain.value, 0.0001), now);
      v.vGain.gain.setTargetAtTime(v.level, now, Math.max(0.02, parseFloat(attackEl.value))*0.6);
    });

    for(let i=voices.length-1;i>=0;i--){
      const v=voices[i]; if(!v._used){
        v.vGain.gain.cancelScheduledValues(now);
        v.vGain.gain.setValueAtTime(Math.max(v.vGain.gain.value, 0.0001), now);
        v.vGain.gain.setTargetAtTime(0.0, now, Math.max(0.04, parseFloat(releaseEl.value))*0.6);
        setTimeout(()=>{ try{ v.osc1.stop(); v.osc2.stop(); }catch{} }, 800);
        voices.splice(i,1);
      }
    }

    if (freqs.length) openEnv(); else closeEnv();
  }

  function applyHarmony(rootHz){
    const out=[rootHz];
    if (h5El.checked) out.push(rootHz*Math.pow(2,7/12));
    if (h9El.checked) out.push(rootHz*Math.pow(2,14/12));
    return out;
  }

  // ===== Mic (optional) =====
  enableMicBtn.onclick = async ()=>{
    try{
      await startAudio();
      if (micStream){ micStream.getTracks().forEach(t=>t.stop()); }
      micStream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
      micStatusEl.textContent="Mic: allowed"; micStatusEl.className="badge ok";
      micSource = audioCtx.createMediaStreamSource(micStream);
      micGain   = audioCtx.createGain(); micGain.gain.value=parseFloat(micGainEl.value);
      preamp    = audioCtx.createGain(); preamp.gain.value=dbToGain(parseFloat(preampEl.value));
      comp      = audioCtx.createDynamicsCompressor();
      comp.threshold.value=-50; comp.knee.value=24; comp.ratio.value=3; comp.attack.value=0.003; comp.release.value=0.25;
      analyser  = audioCtx.createAnalyser(); analyser.fftSize=2048; analyser.smoothingTimeConstant=0.85;
      timeData  = new Float32Array(analyser.fftSize);
      micSource.connect(micGain).connect(preamp).connect(comp).connect(analyser);
      requestAnimationFrame(analyse);
    }catch(e){
      console.warn(e);
      micStatusEl.textContent="Mic: blocked"; micStatusEl.className="badge err";
    }
  };

  // ===== Analysis (Auto-Follow respects Freeze) =====
  function analyse(){
    if (!analyser){ requestAnimationFrame(analyse); return; }
    analyser.getFloatTimeDomainData(timeData);
    let rms=0; for(let i=0;i<timeData.length;i++){ const v=timeData[i]; rms+=v*v; }
    rms=Math.sqrt(rms/timeData.length); const db=rmsToDbfs(rms);
    inDbEl.textContent=`${db.toFixed(1)} dBFS`;
    drawMeter(db);

    const gated = db > parseFloat(gateEl.value);
    const f = gated ? autoCorrelate(timeData, audioCtx.sampleRate) : null;

    if (f && Math.abs(f-lastStableFreq)<1.5) stableCount=Math.min(60,stableCount+1);
    else if (f) stableCount=Math.max(0,stableCount-2);
    else stableCount=Math.max(0,stableCount-4);
    if (f) lastStableFreq = lastStableFreq*0.85 + f*0.15;

    noteEl.textContent = f ? noteNameOf(f) : '—';
    hzEl.textContent   = f ? `${f.toFixed(1)} Hz` : '— Hz';

    // Follow only if not frozen
    if (!holdFrozen && autoFollowEl.checked){
      if (f && stableCount>=6){
        setDrone(applyHarmony(quantizeToET(f)));
      } else {
        setDrone([]);
      }
    }

    requestAnimationFrame(analyse);
  }

  function autoCorrelate(buf, sr){
    const N=buf.length; let rms=0; for (let i=0;i<N;i++){ const v=buf[i]; rms+=v*v; } rms=Math.sqrt(rms/N);
    if (rms<0.001) return null;
    let r1=0,r2=N-1,th=0.2; for (let i=0;i<N/2;i++){ if(Math.abs(buf[i])<th){ r1=i; break; } }
    for (let i=1;i<N/2;i++){ if(Math.abs(buf[N-i])<th){ r2=N-i; break; } }
    buf=buf.slice(r1,r2); const M=buf.length, ac=new Float32Array(M);
    for(let lag=0; lag<M; lag++){ let s=0; for(let i=0;i<M-lag;i++){ s+=buf[i]*buf[i+lag]; } ac[lag]=s; }
    let d=0; while(ac[d]>ac[d+1]) d++; let maxPos=d, maxVal=-1;
    for(let i=d;i<M;i++){ if(ac[i]>maxVal){ maxVal=ac[i]; maxPos=i; } }
    let T0=maxPos;
    if (T0>0 && T0<M-1){ const x1=ac[T0-1],x2=ac[T0],x3=ac[T0+1]; const a=(x1+x3-2*x2)/2,b=(x3-x1)/2; if(a) T0=T0 - b/(2*a); }
    const f=sr/T0; return (f>30 && f<2000)?f:null;
  }
  function quantizeToET(f){ if(!f||!isFinite(f)||f<=0) return f; const midi=Math.round(12*Math.log2(f/A4)+69); return A4*Math.pow(2,(midi-69)/12); }

  // ===== Simple tests & panic =====
  beepBtn?.addEventListener('click', async ()=>{ await startAudio();
    const o=audioCtx.createOscillator(), g=audioCtx.createGain(); g.gain.value=0.2; o.type='sine'; o.frequency.value=440;
    o.connect(g).connect(audioCtx.destination); const t=audioCtx.currentTime; o.start(t); o.stop(t+1); });

  testDirectBtn?.addEventListener('click', async ()=>{ await startAudio();
    const a=audioCtx.createOscillator(), e=audioCtx.createOscillator(), g=audioCtx.createGain();
    a.type='sawtooth'; e.type='triangle'; a.frequency.value=440; e.frequency.value=440*Math.pow(2,7/12);
    g.gain.value=parseFloat(volumeEl.value)*0.25;
    a.connect(g).connect(audioCtx.destination); e.connect(g).connect(audioCtx.destination);
    const t=audioCtx.currentTime; a.start(t); e.start(t); a.stop(t+2); e.stop(t+2); });

  testOrganBtn?.addEventListener('click', async ()=>{ await startAudio();
    setDrone(applyHarmony(440)); setTimeout(()=>setDrone([]), 2000); });

  panicBtn?.addEventListener('click', ()=>{ voices.forEach(v=>{ try{ v.osc1.stop(); v.osc2.stop(); }catch{} }); voices.length=0; closeEnv(); });

  // ===== Freeze / Release =====
  freezeBtn.onclick = ()=>{
    // choose what's sounding; else last stable detection (quantized with harmony)
    let targets = voices.length
      ? voices.map(v=>v.freq)
      : (lastStableFreq>0 ? applyHarmony(quantizeToET(lastStableFreq)) : []);

    if (!targets.length) return; // nothing to freeze
    frozenTargets = targets.slice();
    holdFrozen = true;
    setDrone(frozenTargets);
    freezeBtn.classList.add('toggled');
  };
  releaseBtn.onclick = ()=>{
    holdFrozen = false;
    frozenTargets = [];
    setDrone([]); // envelope will close; analyse() resumes follow next tick
    freezeBtn.classList.remove('toggled');
  };

  // ===== UI bindings + persistence =====
  startBtn.onclick = async ()=>{ await startAudio(); };
  fxOnEl.onchange = ()=>{ setFxActive(fxOnEl.checked); saveSettings(); };
  autoFollowEl.onchange = saveSettings; h5El.onchange=saveSettings; h9El.onchange=saveSettings;

  volumeEl.oninput = e=>{ volVal.textContent=(+e.target.value).toFixed(2); if(outGain) outGain.gain.value=parseFloat(e.target.value); saveSettings(); };
  attackEl.oninput = e=>{ attackVal.textContent=(+e.target.value).toFixed(2)+'s'; saveSettings(); };
  releaseEl.oninput= e=>{ releaseVal.textContent=(+e.target.value).toFixed(2)+'s'; saveSettings(); };
  toneEl.oninput   = e=>{ const v=parseFloat(e.target.value); toneVal.textContent=Math.round(v)+' Hz'; if(lpf) lpf.frequency.value=v; voices.forEach(vv=>vv.vf.frequency.value=v); saveSettings(); };
  chorusEl.oninput = e=>{ const v=parseFloat(e.target.value); chorusVal.textContent=v.toFixed(2); if(d1&&d2){ d1.delayTime.value=0.008+0.016*v; d2.delayTime.value=0.012+0.020*v; } saveSettings(); };
  reverbEl.oninput = e=>{ const v=parseFloat(e.target.value); reverbVal.textContent=v.toFixed(2); if(revMix) revMix.gain.value=v; saveSettings(); };

  micGainEl.oninput= e=>{ micGainVal.textContent=(+e.target.value).toFixed(2); if(micGain) micGain.gain.value=parseFloat(e.target.value); saveSettings(); };
  preampEl.oninput = e=>{ const db=parseFloat(e.target.value); preampVal.textContent=`+${db} dB`; if(preamp) preamp.gain.value=dbToGain(db); saveSettings(); };
  gateEl.oninput   = e=>{ gateVal.textContent=`${(+e.target.value).toFixed(0)} dBFS`; saveSettings(); };

  function updateCtxState(){ ctxStateEl.textContent = audioCtx ? audioCtx.state : "—"; }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && audioCtx && audioCtx.state!=='running'){ audioCtx.resume().then(updateCtxState); } });

  // ===== Visualiser (fixed) =====
  // Draws continuously, even before audio starts. Uses envelope when available,
  // plus a subtle idle pulse so it never looks “stuck”.
  const noise=(n=>{ const a=new Float32Array(n); for(let i=0;i<n;i++) a[i]=Math.random(); return a; })(256);
  const vn1=p=>{ const n=noise.length,i0=Math.floor(p)%n,i1=(i0+1)%n,t=p-Math.floor(p); return (1-t)*noise[i0]+t*noise[i1]; };
  const fbm=(x,y,z)=>{ let tot=0,amp=0.6,f=1; for(let o=0;o<4;o++){ const s=vn1(x*f+y*f*1.37+z*f*0.77); tot+=s*amp; amp*=0.5; f*=2.1; } return tot; };

  function draw(){
    // Ensure canvas is properly sized to devicePixelRatio
    const rect=canvas.getBoundingClientRect(), ratio=window.devicePixelRatio||1;
    const wantW=Math.floor(rect.width*ratio), wantH=Math.floor(420*ratio);
    if (canvas.width!==wantW || canvas.height!==wantH){ canvas.width=wantW; canvas.height=wantH; }

    // Envelope visual (fallback to idle pulse if audio not started)
    const t=performance.now();
    const idle = 0.12 + 0.08*Math.sin(t*0.0013); // gentle breathing when silent
    const env = (audioCtx && envGain) ? envGain.gain.value : 0;
    envVis = envVis*0.9 + (env||0)*0.1;
    const intensity = clamp(envVis + idle*(1-envVis), 0, 1);

    // Background fade (darker to avoid white look)
    vctx.globalCompositeOperation='source-over';
    vctx.fillStyle='rgba(6,10,15,0.2)';
    vctx.fillRect(0,0,canvas.width,canvas.height);

    // Mist layers
    const scale = 0.004 + 0.0015*intensity;
    for(let L=0; L<3; L++){
      const alpha = 0.06 + 0.16*intensity*(1-L/3);
      vctx.globalAlpha=alpha;
      vctx.globalCompositeOperation='lighter';
      const hue = 200 + (270-200)*(0.25+0.75*intensity) + L*5;
      vctx.fillStyle = `hsla(${hue},85%,${40+L*4}%,${alpha})`;
      const step = 12 + L*4;
      for(let y=0;y<canvas.height;y+=step){
        for(let x=0;x<canvas.width;x+=step){
          const n=fbm(x*scale, y*scale, t*0.00045 + L*10);
          const r = step*(0.8 + 1.9*n*intensity);
          vctx.beginPath(); vctx.ellipse(x,y,r,r*0.7,0,0,Math.PI*2); vctx.fill();
        }
      }
    }
    vctx.globalAlpha=1;
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // Meter
  function drawMeter(db){
    const w=inMeter.width,h=inMeter.height; mctx.clearRect(0,0,w,h);
    const n=Math.max(0,Math.min(1,(db+90)/90));
    mctx.fillStyle='rgba(255,255,255,.06)'; mctx.fillRect(0,0,w,h);
    mctx.fillStyle = n>0.95?'#ff6b6b':(n>0.8?'#ffcc66':'#69e089');
    mctx.fillRect(0,0,Math.floor(w*n),h);
  }

})();
</script>
</body>
</html>
