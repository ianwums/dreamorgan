<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Misty Drone — Dream Organ (Feature Build v1.3.3 — mobile)</title>
<style>
  :root {
    --bg:#0b0f14; --text:#e9f1f7; --muted:#94a3b8; --accent:#67d4ff; --accent2:#b486ff;
    --good:#69e089; --warn:#ffcc66; --bad:#ff6b6b;
    --viz-h: 420px; /* desktop visualiser height fallback */
  }
  html,body{
    height:100%; margin:0; background:
      radial-gradient(1200px 700px at 70% -10%, rgba(103,212,255,.06), transparent 60%),
      radial-gradient(900px 600px at -10% 120%, rgba(180,134,255,.07), transparent 60%),
      var(--bg);
    color:var(--text);
    font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
  }
  .wrap{max-width:1100px;margin:24px auto;padding:16px;}
  header{
    position: sticky; top: env(safe-area-inset-top, 0px);
    z-index: 10; backdrop-filter: blur(8px);
    background: linear-gradient(180deg, rgba(10,14,20,.7), rgba(10,14,20,.35));
    border: 1px solid rgba(255,255,255,.06);
    padding:12px;border-radius:14px;margin-bottom:16px;
  }
  h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.4px;}
  .pill{padding:6px 10px;border-radius:999px;background:linear-gradient(135deg,rgba(103,212,255,.18),rgba(180,134,255,.18));border:1px solid rgba(255,255,255,.12);color:var(--muted);font-size:12px;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{appearance:none;border:0;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;color:#0b0f14;
       background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 10px 24px rgba(103,212,255,.25), inset 0 1px 0 rgba(255,255,255,.3);}
  .btn.secondary{background:rgba(255,255,255,.08); color:var(--text); border:1px solid rgba(255,255,255,.14); box-shadow:none;}
  .btn.toggled{outline:2px solid var(--accent); background:rgba(103,212,255,.16); color:var(--text);}
  .state{font-size:12px;color:var(--muted);}
  .badge{padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.06);}
  .ok{border-color:rgba(105,224,137,.4); background:rgba(105,224,137,.12);}
  .err{border-color:rgba(255,107,107,.4); background:rgba(255,107,107,.12);}

  .grid{display:grid;gap:16px;grid-template-columns:1.1fr 1fr;}
  @media (max-width:980px){.grid{grid-template-columns:1fr;}}
  .panel{padding:14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));}
  .panel h2{margin:0 0 10px;font-size:14px;color:var(--muted);letter-spacing:.3px;}
  .controls{display:grid;gap:10px;grid-template-columns:repeat(2,minmax(0,1fr));}
  .control{background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.06);padding:10px;border-radius:12px;}
  .control label{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px;margin-bottom:6px;}
  input[type="range"]{width:100%;accent-color:#7ed3ff;touch-action:pan-y;}
  /* iOS-friendly slider thumbs */
  input[type="range"]::-webkit-slider-thumb{appearance:none; width:22px; height:22px; border-radius:50%; background:#e9f1f7; border:1px solid rgba(0,0,0,.25);}
  input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:50%;background:#e9f1f7;border:0;}
  .chip{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.07);border-radius:12px;padding:10px;}
  .note{font-size:26px;font-weight:700}
  #mist{
    width:100%;
    height:var(--viz-h);
    border-radius:14px;display:block;background:#0b0f14;
  }
  .toggles{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px;margin-top:8px}
  .toggle{display:flex;align-items:center;justify-content:space-between;gap:6px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px;font-size:12px;color:var(--muted);}
  .toggle span.label{display:flex;align-items:center;gap:8px}
  .key{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;font-size:11px;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.08);color:var(--text);}

  details.debug summary{cursor:pointer; color:var(--muted); user-select:none;}
  details.debug{margin-top:10px}

  /* ======== iPhone breakpoint (13 mini and similar) ======== */
  @media (max-width:430px){
    :root{ --viz-h: min(50vh, 360px); }
    body{ font-size:14px; }
    .wrap{ padding-left: max(8px, env(safe-area-inset-left)); padding-right:max(8px, env(safe-area-inset-right)); padding-bottom: max(8px, env(safe-area-inset-bottom)); margin:16px auto; }
    header{ padding:10px; border-radius:12px; }
    h1{ font-size:18px; }
    .row{ gap:8px; }
    .btn{ padding:12px 14px; font-size:14px; }
    .grid{ gap:12px; }
    .panel{ padding:12px; border-radius:12px; }
    .controls{ grid-template-columns:1fr; } /* stack controls */
    .toggles{ grid-template-columns:repeat(3,minmax(0,1fr)); } /* 3-wide grid */
    .note{ font-size:22px; }
    /* Keep critical buttons visible: split header rows vertically */
    header .row:first-child{ justify-content:space-between; }
    header .row:nth-child(2){ justify-content:flex-start; }
    header .row:nth-child(3){ justify-content:flex-start; }
    /* Make meter taller for legibility */
    #inMeter{ height:16px; }
  }

  /* Prevent text selection while tapping buttons on iOS */
  * { -webkit-tap-highlight-color: rgba(255,255,255,0.08); }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="row">
      <h1>Misty Drone</h1>
      <span class="pill">dreamy organ — v1.3.3</span>
    </div>
    <div class="row">
      <button id="startBtn" class="btn">Start Audio</button>
      <label class="row" style="gap:6px;"><input id="fxOn" type="checkbox"><span class="state">FX On</span></label>
      <label class="row" style="gap:6px;"><input id="autoFollow" type="checkbox" checked><span class="state">Auto-Follow Mic</span></label>
      <button id="freezeBtn" class="btn secondary" title="Hold current notes">Freeze</button>
      <button id="releaseBtn" class="btn secondary" title="Release held notes">Release</button>
    </div>
    <div class="row">
      <button id="enableMicBtn" class="btn secondary">Enable Mic</button>
      <span class="state">AudioContext: <span id="ctxState">—</span></span>
      <span id="micStatus" class="badge">Mic: —</span>
    </div>
  </header>

  <div class="grid">
    <section class="panel">
      <h2>Organ</h2>
      <div class="controls">
        <div class="control"><label>Master Volume <span id="volVal">0.80</span></label><input id="volume" type="range" min="0" max="1" step="0.01" value="0.80"/></div>
        <div class="control"><label>Attack <span id="attackVal">0.80s</span></label><input id="attack" type="range" min="0" max="3" step="0.01" value="0.80"/></div>
        <div class="control"><label>Release <span id="releaseVal">2.50s</span></label><input id="release" type="range" min="0.1" max="6" step="0.05" value="2.5"/></div>
        <div class="control"><label>Tone (LPF) <span id="toneVal">1800 Hz</span></label><input id="tone" type="range" min="300" max="6000" step="10" value="1800"/></div>
        <div class="control"><label>Chorus Width <span id="chorusVal">0.35</span></label><input id="chorus" type="range" min="0" max="1" step="0.01" value="0.35"/></div>
        <div class="control"><label>Reverb Mix <span id="reverbVal">0.25</span></label><input id="reverb" type="range" min="0" max="0.9" step="0.01" value="0.25"/></div>

        <div class="control" style="grid-column:1/-1;">
          <label>
            <span class="label">Harmony (combine freely)</span>
            <span class="state">Keyboard: Q W E R T Y U I O P [ ]</span>
          </label>
          <div class="toggles">
            <label class="toggle"><span class="label"><input id="h_m3" type="checkbox"> m3</span><span class="key">Q</span></label>
            <label class="toggle"><span class="label"><input id="h_M3" type="checkbox"> M3</span><span class="key">W</span></label>
            <label class="toggle"><span class="label"><input id="h_P4" type="checkbox"> P4</span><span class="key">E</span></label>
            <label class="toggle"><span class="label"><input id="h_P5" type="checkbox" checked> P5</span><span class="key">R</span></label>
            <label class="toggle"><span class="label"><input id="h_M6" type="checkbox"> M6</span><span class="key">T</span></label>
            <label class="toggle"><span class="label"><input id="h_m7" type="checkbox"> m7</span><span class="key">Y</span></label>
            <label class="toggle"><span class="label"><input id="h_M7" type="checkbox"> M7</span><span class="key">U</span></label>
            <label class="toggle"><span class="label"><input id="h_9"  type="checkbox"> 9th</span><span class="key">I</span></label>
            <label class="toggle"><span class="label"><input id="h_11" type="checkbox"> 11th</span><span class="key">O</span></label>
            <label class="toggle"><span class="label"><input id="h_13" type="checkbox"> 13th</span><span class="key">P</span></label>
            <label class="toggle"><span class="label"><input id="h_octU" type="checkbox"> +8ve</span><span class="key">[</span></label>
            <label class="toggle"><span class="label"><input id="h_octD" type="checkbox"> −8ve</span><span class="key">]</span></label>
          </div>
        </div>
      </div>

      <details class="debug" open>
        <summary>Debug tools</summary>
        <div class="row" style="margin-top:8px;">
          <button id="beepBtn" class="btn secondary">Beep 1s</button>
          <button id="testDirectBtn" class="btn secondary">Test Drone (Direct)</button>
          <button id="testOrganBtn" class="btn secondary">Test Drone (Organ Path)</button>
          <button id="panicBtn" class="btn secondary" title="kills voices">Panic</button>
        </div>
      </details>
    </section>

    <section class="panel">
      <h2>Mic & Detection</h2>
      <div class="controls">
        <div class="control"><label>Input Gain <span id="micGainVal">1.00</span></label><input id="micGain" type="range" min="0" max="3" step="0.01" value="1.0"/></div>
        <div class="control"><label>Preamp Boost <span id="preampVal">+0 dB</span></label><input id="preamp" type="range" min="0" max="30" step="1" value="0"/></div>
        <div class="control"><label>Input Gate <span id="gateVal">-60 dBFS</span></label><input id="gate" type="range" min="-90" max="-30" step="1" value="-60"/></div>
      </div>
      <div class="controls" style="grid-template-columns:1fr;">
        <div class="chip">
          <div class="row" style="justify-content:space-between"><div>Input Level</div><div id="inDb">mic off</div></div>
          <canvas id="inMeter" width="300" height="12" style="width:100%;height:12px;border-radius:8px;background:rgba(255,255,255,.05)"></canvas>
        </div>
        <div class="chip">
          <div>Dominant Pitch</div>
          <div class="note" id="noteName">—</div>
          <div id="hz" class="state">— Hz</div>
        </div>
      </div>
    </section>
  </div>

  <section class="panel" style="margin-top:16px">
    <h2>Visualizer</h2>
    <canvas id="mist" width="900" height="450"></canvas>
  </section>
</div>

<script>
(function(){
  // ===== Utilities =====
  const A4=440, NOTE_NAMES=["C","C♯","D","E♭","E","F","F♯","G","A♭","A","B♭","B"];
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const dbToGain=db=>Math.pow(10, db/20);
  const rmsToDbfs=rms=>20*Math.log10(rms || 1e-12);
  const noteNameOf=f=>{ if(!f||!isFinite(f)||f<=0) return "—"; const n=Math.round(12*Math.log2(f/A4))+69; return NOTE_NAMES[(n%12+12)%12]+(Math.floor(n/12)-1); };
  const LS_KEY='misty-drone-v1.3.3';

  // ===== DOM =====
  const $=id=>document.getElementById(id);
  const startBtn=$("startBtn"), enableMicBtn=$("enableMicBtn");
  const beepBtn=$("beepBtn"), testDirectBtn=$("testDirectBtn"), testOrganBtn=$("testOrganBtn"), panicBtn=$("panicBtn");
  const ctxStateEl=$("ctxState"), micStatusEl=$("micStatus");
  const volumeEl=$("volume"), attackEl=$("attack"), releaseEl=$("release"), toneEl=$("tone"), chorusEl=$("chorus"), reverbEl=$("reverb"), fxOnEl=$("fxOn");
  const volVal=$("volVal"), attackVal=$("attackVal"), releaseVal=$("releaseVal"), toneVal=$("toneVal"), chorusVal=$("chorusVal"), reverbVal=$("reverbVal");
  const micGainEl=$("micGain"), preampEl=$("preamp"), gateEl=$("gate"), micGainVal=$("micGainVal"), preampVal=$("preampVal"), gateVal=$("gateVal");
  const inMeter=$("inMeter"), mctx=inMeter.getContext("2d"), inDbEl=$("inDb");
  const noteEl=$("noteName"), hzEl=$("hz");
  const autoFollowEl=$("autoFollow");
  const freezeBtn=$("freezeBtn"), releaseBtn=$("releaseBtn");
  const canvas=$("mist"), vctx=canvas.getContext("2d");

  // Harmony toggles
  const H = {
    m3: $("h_m3"), M3: $("h_M3"), P4: $("h_P4"), P5: $("h_P5"),
    M6: $("h_M6"), m7: $("h_m7"), M7: $("h_M7"), _9: $("h_9"),
    _11: $("h_11"), _13: $("h_13"), octU: $("h_octU"), octD: $("h_octD"),
  };

  // ===== Audio state =====
  let audioCtx;
  let envGain, outGain, limiter;
  let lpf, d1, d2, lfo1, lfo2, lfoG1, lfoG2, dryMix, revSend, convolver, revRet, revMix, fxOut;
  let micStream, micSource, micGain, preamp, comp, analyser, timeData;
  let lastStableFreq=0, stableCount=0, envVis=0;
  let voices=[];

  // Freeze state
  let holdFrozen=false;
  let frozenTargets=[];
  let frozenRootHz=0;

  // ===== Settings =====
  function saveSettings(){
    const data={
      volume:+volumeEl.value, attack:+attackEl.value, release:+releaseEl.value, tone:+toneEl.value,
      chorus:+chorusEl.value, reverb:+reverbEl.value, fxOn:fxOnEl.checked,
      micGain:+micGainEl.value, preamp:+preampEl.value, gate:+gateEl.value,
      autoFollow:autoFollowEl.checked,
      harm: Object.fromEntries(Object.entries(H).map(([k,el])=>[k, el.checked]))
    };
    localStorage.setItem(LS_KEY, JSON.stringify(data));
  }
  function loadSettings(){
    try{
      const data=JSON.parse(localStorage.getItem(LS_KEY)||'{}');
      for (const [k,v] of Object.entries(data)){
        const el=({volume:volumeEl,attack:attackEl,release:releaseEl,tone:toneEl,chorus:chorusEl,reverb:reverbEl,
                   micGain:micGainEl,preamp:preampEl,gate:gateEl}[k]);
        if (el) el.value=v;
        if (k==='fxOn') fxOnEl.checked=v;
        if (k==='autoFollow') autoFollowEl.checked=v;
        if (k==='harm' && typeof v==='object'){ for (const [hk,hv] of Object.entries(v)){ if (H[hk]) H[hk].checked = hv; } }
      }
    }catch{}
    volVal.textContent=(+volumeEl.value).toFixed(2);
    attackVal.textContent=(+attackEl.value).toFixed(2)+'s';
    releaseVal.textContent=(+releaseEl.value).toFixed(2)+'s';
    toneVal.textContent=Math.round(+toneEl.value)+' Hz';
    chorusVal.textContent=(+chorusEl.value).toFixed(2);
    reverbVal.textContent=(+reverbEl.value).toFixed(2);
    micGainVal.textContent=(+micGainEl.value).toFixed(2);
    preampVal.textContent=`+${(+preampEl.value).toFixed(0)} dB`;
    gateVal.textContent=`${(+gateEl.value).toFixed(0)} dBFS`;
  }
  loadSettings();

  // ===== Start Audio =====
  async function startAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)({ latencyHint:"interactive" });
    updateCtxState();

    envGain = audioCtx.createGain(); envGain.gain.value=0.0001;
    outGain = audioCtx.createGain(); outGain.gain.value=parseFloat(volumeEl.value);

    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value=-3; limiter.knee.value=6; limiter.ratio.value=4; limiter.attack.value=0.003; limiter.release.value=0.25;

    envGain.connect(outGain).connect(limiter).connect(audioCtx.destination);

    lpf = audioCtx.createBiquadFilter(); lpf.type="lowpass"; lpf.frequency.value=parseFloat(toneEl.value); lpf.Q.value=0.5;
    d1 = audioCtx.createDelay(); d2 = audioCtx.createDelay(); d1.delayTime.value=0.012; d2.delayTime.value=0.018;
    lfo1 = audioCtx.createOscillator(); lfo2 = audioCtx.createOscillator(); lfoG1 = audioCtx.createGain(); lfoG2 = audioCtx.createGain();
    lfo1.frequency.value=0.28; lfo2.frequency.value=0.41; lfoG1.gain.value=0.006; lfoG2.gain.value=0.008;
    lfo1.connect(lfoG1).connect(d1.delayTime); lfo2.connect(lfoG2).connect(d2.delayTime); lfo1.start(); lfo2.start();
    dryMix = audioCtx.createGain(); dryMix.gain.value=1.0;
    revSend = audioCtx.createGain(); revSend.gain.value=0.25;
    convolver = audioCtx.createConvolver(); convolver.buffer=buildIR(audioCtx,2.2,0.4);
    revRet = audioCtx.createGain(); revRet.gain.value=1.0;
    revMix = audioCtx.createGain(); revMix.gain.value=parseFloat(reverbEl.value);
    fxOut = audioCtx.createGain(); fxOut.gain.value=1.0;

    envGain.connect(lpf);
    lpf.connect(d1); lpf.connect(d2);
    d1.connect(dryMix); d2.connect(dryMix);
    dryMix.connect(revSend); revSend.connect(convolver); convolver.connect(revRet); revRet.connect(revMix);
    dryMix.connect(fxOut); revMix.connect(fxOut);
    fxOut.connect(outGain);

    setFxActive(fxOnEl.checked);
  }

  function setFxActive(on){
    if (!audioCtx) return;
    fxOut.gain.setValueAtTime(on ? 1.0 : 0.0, audioCtx.currentTime);
  }

  // ===== Organ voices =====
  function makeVoice(freq){
    const osc1=audioCtx.createOscillator(), osc2=audioCtx.createOscillator();
    const vGain=audioCtx.createGain(); vGain.gain.value=0.0001;
    const vf=audioCtx.createBiquadFilter(); vf.type='lowpass'; vf.frequency.value=parseFloat(toneEl.value);
    const lfo=audioCtx.createOscillator(), lg=audioCtx.createGain();
    lfo.frequency.value=0.12+Math.random()*0.08; lg.gain.value=4+Math.random()*4; lfo.connect(lg).connect(osc2.detune);
    osc1.type='sawtooth'; osc2.type='triangle'; osc1.frequency.value=freq*0.995; osc2.frequency.value=freq*1.005;
    osc1.connect(vGain); osc2.connect(vGain); vGain.connect(vf).connect(envGain);
    const t=audioCtx.currentTime; osc1.start(t); osc2.start(t); lfo.start(t);
    const level = 0.25 / Math.sqrt(1 + voices.length);
    return {osc1,osc2,vGain,level,vf,freq,_used:true};
  }

  function openEnv(){
    const now=audioCtx?.currentTime||0;
    envGain.gain.cancelScheduledValues(now);
    envGain.gain.setValueAtTime(Math.max(envGain.gain.value, 0.0001), now);
    envGain.gain.setTargetAtTime(1.0, now, Math.max(0.02, parseFloat(attackEl.value))*0.6);
  }
  function closeEnv(){
    const now=audioCtx?.currentTime||0;
    envGain.gain.cancelScheduledValues(now);
    envGain.gain.setValueAtTime(Math.max(envGain.gain.value, 0.0001), now);
    envGain.gain.setTargetAtTime(0.0, now, Math.max(0.04, parseFloat(releaseEl.value))*0.6);
  }

  function setDrone(freqs){
    if (!audioCtx) return;
    const now=audioCtx.currentTime;
    voices.forEach(v=>v._used=false);
    freqs.forEach(f=>{
      let v=voices.find(v=>Math.abs(v.freq - f) < 0.5);
      if(!v){ v=makeVoice(f); voices.push(v); }
      v._used=true; v.freq=f;
      v.osc1.frequency.setValueAtTime(f*0.995, now);
      v.osc2.frequency.setValueAtTime(f*1.005, now);
      v.vGain.gain.cancelScheduledValues(now);
      v.vGain.gain.setValueAtTime(Math.max(v.vGain.gain.value, 0.0001), now);
      v.vGain.gain.setTargetAtTime(v.level, now, Math.max(0.02, parseFloat(attackEl.value))*0.6);
    });
    for(let i=voices.length-1;i>=0;i--){
      const v=voices[i]; if(!v._used){
        v.vGain.gain.cancelScheduledValues(now);
        v.vGain.gain.setValueAtTime(Math.max(v.vGain.gain.value, 0.0001), now);
        v.vGain.gain.setTargetAtTime(0.0, now, Math.max(0.04, parseFloat(releaseEl.value))*0.6);
        setTimeout(()=>{ try{ v.osc1.stop(); v.osc2.stop(); }catch{} }, 800);
        voices.splice(i,1);
      }
    }
    if (freqs.length) openEnv(); else closeEnv();
  }

  // Harmony helpers
  function semitone(n){ return Math.pow(2, n/12); }
  function applyHarmony(rootHz){
    const freqs = new Set([rootHz]);
    if (H.m3.checked) freqs.add(rootHz * semitone(3));
    if (H.M3.checked) freqs.add(rootHz * semitone(4));
    if (H.P4.checked) freqs.add(rootHz * semitone(5));
    if (H.P5.checked) freqs.add(rootHz * semitone(7));
    if (H.M6.checked) freqs.add(rootHz * semitone(9));
    if (H.m7.checked) freqs.add(rootHz * semitone(10));
    if (H.M7.checked) freqs.add(rootHz * semitone(11));
    if (H._9.checked)  freqs.add(rootHz * semitone(14));
    if (H._11.checked) freqs.add(rootHz * semitone(17));
    if (H._13.checked) freqs.add(rootHz * semitone(21));
    if (H.octU.checked) freqs.add(rootHz * semitone(12));
    if (H.octD.checked) freqs.add(rootHz * semitone(-12));
    return Array.from(freqs).sort((a,b)=>a-b);
  }

  // ===== Mic (optional) =====
  enableMicBtn.onclick = async ()=>{
    try{
      await startAudio();
      if (micStream){ micStream.getTracks().forEach(t=>t.stop()); }
      micStream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }});
      micStatusEl.textContent="Mic: allowed"; micStatusEl.className="badge ok";
      micSource = audioCtx.createMediaStreamSource(micStream);
      micGain   = audioCtx.createGain(); micGain.gain.value=parseFloat(micGainEl.value);
      preamp    = audioCtx.createGain(); preamp.gain.value=dbToGain(parseFloat(preampEl.value));
      comp      = audioCtx.createDynamicsCompressor();
      comp.threshold.value=-50; comp.knee.value=24; comp.ratio.value=3; comp.attack.value=0.003; comp.release.value=0.25;
      analyser  = audioCtx.createAnalyser(); analyser.fftSize=2048; analyser.smoothingTimeConstant=0.85;
      timeData  = new Float32Array(analyser.fftSize);
      micSource.connect(micGain).connect(preamp).connect(comp).connect(analyser);
      requestAnimationFrame(analyse);
    }catch(e){
      console.warn(e);
      micStatusEl.textContent="Mic: blocked"; micStatusEl.className="badge err";
    }
  };

  // ===== Analysis =====
  function analyse(){
    if (!analyser){ requestAnimationFrame(analyse); return; }
    analyser.getFloatTimeDomainData(timeData);
    let rms=0; for(let i=0;i<timeData.length;i++){ const v=timeData[i]; rms+=v*v; }
    rms=Math.sqrt(rms/timeData.length); const db=rmsToDbfs(rms);
    inDbEl.textContent=`${db.toFixed(1)} dBFS`;
    drawMeter(db);

    const gated = db > parseFloat(gateEl.value);
    const f = gated ? autoCorrelate(timeData, audioCtx.sampleRate) : null;

    if (f && Math.abs(f-lastStableFreq)<1.5) stableCount=Math.min(60,stableCount+1);
    else if (f) stableCount=Math.max(0,stableCount-2);
    else stableCount=Math.max(0,stableCount-4);
    if (f) lastStableFreq = lastStableFreq*0.85 + f*0.15;

    noteEl.textContent = f ? noteNameOf(f) : '—';
    hzEl.textContent   = f ? `${f.toFixed(1)} Hz` : '— Hz';

    if (!holdFrozen && autoFollowEl.checked){
      if (f && stableCount>=6){
        setDrone(applyHarmony(quantizeToET(f)));
      } else {
        setDrone([]);
      }
    }
    requestAnimationFrame(analyse);
  }

  function autoCorrelate(buf, sr){
    const N=buf.length; let rms=0; for (let i=0;i<N;i++){ const v=buf[i]; rms+=v*v; } rms=Math.sqrt(rms/N);
    if (rms<0.001) return null;
    let r1=0,r2=N-1,th=0.2; for (let i=0;i<N/2;i++){ if(Math.abs(buf[i])<th){ r1=i; break; } }
    for (let i=1;i<N/2;i++){ if(Math.abs(buf[N-i])<th){ r2=N-i; break; } }
    buf=buf.slice(r1,r2); const M=buf.length, ac=new Float32Array(M);
    for(let lag=0; lag<M; lag++){ let s=0; for(let i=0;i<M-lag;i++){ s+=buf[i]*buf[i+lag]; } ac[lag]=s; }
    let d=0; while(ac[d]>ac[d+1]) d++; let maxPos=d, maxVal=-1;
    for(let i=d;i<M;i++){ if(ac[i]>maxVal){ maxVal=ac[i]; maxPos=i; } }
    let T0=maxPos;
    if (T0>0 && T0<M-1){ const x1=ac[T0-1],x2=ac[T0],x3=ac[T0+1]; const a=(x1+x3-2*x2)/2,b=(x3-x1)/2; if(a) T0=T0 - b/(2*a); }
    const f=sr/T0; return (f>30 && f<2000)?f:null;
  }
  function quantizeToET(f){ if(!f||!isFinite(f)||f<=0) return f; const midi=Math.round(12*Math.log2(f/A4)+69); return A4*Math.pow(2,(midi-69)/12); }

  // ===== Tests & panic =====
  beepBtn?.addEventListener('click', async ()=>{ await startAudio();
    const o=audioCtx.createOscillator(), g=audioCtx.createGain(); g.gain.value=0.2; o.type='sine'; o.frequency.value=440;
    o.connect(g).connect(audioCtx.destination); const t=audioCtx.currentTime; o.start(t); o.stop(t+1); });

  testDirectBtn?.addEventListener('click', async ()=>{ await startAudio();
    const a=audioCtx.createOscillator(), e=audioCtx.createOscillator(), g=audioCtx.createGain();
    a.type='sawtooth'; e.type='triangle'; a.frequency.value=440; e.frequency.value=440*Math.pow(2,7/12);
    g.gain.value=parseFloat(volumeEl.value)*0.25;
    a.connect(g).connect(audioCtx.destination); e.connect(g).connect(audioCtx.destination);
    const t=audioCtx.currentTime; a.start(t); e.start(t); a.stop(t+2); e.stop(t+2); });

  testOrganBtn?.addEventListener('click', async ()=>{ await startAudio();
    setDrone(applyHarmony(440)); setTimeout(()=>setDrone([]), 2000); });

  panicBtn?.addEventListener('click', ()=>{ voices.forEach(v=>{ try{ v.osc1.stop(); v.osc2.stop(); }catch{} }); voices.length=0; closeEnv(); });

  // ===== Freeze / Release =====
  function currentRootFromVoices(){
    if (voices.length) return Math.min(...voices.map(v=>v.freq)); // lowest voice
    if (lastStableFreq>0) return quantizeToET(lastStableFreq);
    return 0;
  }
  function updateFrozenIfNeeded(){
    if (holdFrozen && frozenRootHz>0){
      frozenTargets = applyHarmony(frozenRootHz);
      setDrone(frozenTargets);
    }
  }

  freezeBtn.onclick = ()=>{
    const root = currentRootFromVoices();
    if (!root) return;
    frozenRootHz = root;
    frozenTargets = applyHarmony(frozenRootHz);
    holdFrozen = true;
    setDrone(frozenTargets);
    freezeBtn.classList.add('toggled');
  };
  releaseBtn.onclick = ()=>{
    holdFrozen = false;
    frozenTargets = [];
    frozenRootHz = 0;
    setDrone([]);
    freezeBtn.classList.remove('toggled');
  };

  // ===== UI + persistence =====
  const H_all = Object.values(H);
  startBtn.onclick = async ()=>{ await startAudio(); };
  fxOnEl.onchange = ()=>{ setFxActive(fxOnEl.checked); saveSettings(); };
  autoFollowEl.onchange = saveSettings;
  H_all.forEach(el=> el.addEventListener('change', ()=>{ saveSettings(); updateFrozenIfNeeded(); }));

  volumeEl.oninput = e=>{ volVal.textContent=(+e.target.value).toFixed(2); if(outGain) outGain.gain.value=parseFloat(e.target.value); saveSettings(); };
  attackEl.oninput = e=>{ attackVal.textContent=(+e.target.value).toFixed(2)+'s'; saveSettings(); };
  releaseEl.oninput= e=>{ releaseVal.textContent=(+e.target.value).toFixed(2)+'s'; saveSettings(); };
  toneEl.oninput   = e=>{ const v=parseFloat(e.target.value); toneVal.textContent=Math.round(v)+' Hz'; if(lpf) lpf.frequency.value=v; voices.forEach(vv=>vv.vf.frequency.value=v); saveSettings(); };
  chorusEl.oninput = e=>{ const v=parseFloat(e.target.value); chorusVal.textContent=v.toFixed(2); if(d1&&d2){ d1.delayTime.value=0.008+0.016*v; d2.delayTime.value=0.012+0.020*v; } saveSettings(); };
  reverbEl.oninput = e=>{ const v=parseFloat(e.target.value); reverbVal.textContent=v.toFixed(2); if(revMix) revMix.gain.value=v; saveSettings(); };

  micGainEl.oninput= e=>{ micGainVal.textContent=(+e.target.value).toFixed(2); if(micGain) micGain.gain.value=parseFloat(e.target.value); saveSettings(); };
  preampEl.oninput = e=>{ const db=parseFloat(e.target.value); preampVal.textContent=`+${db} dB`; if(preamp) preamp.gain.value=dbToGain(db); saveSettings(); };
  gateEl.oninput   = e=>{ gateVal.textContent=`${(+e.target.value).toFixed(0)} dBFS`; saveSettings(); };

  function updateCtxState(){ ctxStateEl.textContent = audioCtx ? audioCtx.state : "—"; }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && audioCtx && audioCtx.state!=='running'){ audioCtx.resume().then(updateCtxState); } });

  // ===== Keyboard shortcuts for harmonics (desktop convenience) =====
  const keyMap = {
    'q': H.m3, 'w': H.M3, 'e': H.P4, 'r': H.P5, 't': H.M6, 'y': H.m7,
    'u': H.M7, 'i': H._9, 'o': H._11, 'p': H._13, '[': H.octU, ']': H.octD
  };
  window.addEventListener('keydown', (e)=>{
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
    if (tag==='input' || tag==='select' || tag==='textarea' || e.metaKey || e.ctrlKey || e.altKey) return;
    if (e.repeat) return;
    const k = e.key.toLowerCase();
    const el = keyMap[k];
    if (el){
      e.preventDefault();
      el.checked = !el.checked;
      el.dispatchEvent(new Event('change', {bubbles:true}));
      const label = el.closest('.toggle');
      if (label){ label.style.outline='2px solid rgba(103,212,255,.6)'; setTimeout(()=>{ label.style.outline=''; }, 120); }
    }
  });

  // ===== Visualiser: two giant ASCII cats =====
  const noise=(n=>{ const a=new Float32Array(n); for(let i=0;i<n;i++) a[i]=Math.random(); return a; })(256);
  const vn1=p=>{ const n=noise.length,i0=Math.floor(p)%n,i1=(i0+1)%n,t=p-Math.floor(p); return (1-t)*noise[i0]+t*noise[i1]; };
  const fbm=(x,y,z)=>{ let tot=0,amp=0.6,f=1; for(let o=0;o<4;o++){ const s=vn1(x*f+y*f*1.37+z*f*0.77); tot+=s*amp; amp*=0.5; f*=2.1; } return tot; };

  const catL = [
`  /\\_/\\
 ( o.o )
  > ^ <`,
`  /\\_/\\
 ( -.- )
  > ^ <`,
`  /\\_/\\
 ( o.o )
  > v <`
  ];
  const catR = [
`  /\\_/\\
 ( o.o )
  < ^ >`,
`  /\\_/\\
 ( -.- )
  < ^ >`,
`  /\\_/\\
 ( o.o )
  < v >`
  ];
  let catIndex=0, catTimer=0;

  function draw(){
    const rect=canvas.getBoundingClientRect(), ratio=window.devicePixelRatio||1;
    const wantW=Math.floor(rect.width*ratio), wantH=Math.floor(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--viz-h'))*ratio);
    if (canvas.width!==wantW || canvas.height!==wantH){ canvas.width=wantW; canvas.height=wantH; }
    const t=performance.now();

    const idle = 0.12 + 0.08*Math.sin(t*0.0013);
    const env = (audioCtx && envGain) ? envGain.gain.value : 0;
    envVis = envVis*0.9 + (env||0)*0.1;
    const intensity = clamp(envVis + idle*(1-envVis), 0, 1);

    vctx.globalCompositeOperation='source-over';
    vctx.fillStyle='rgba(6,10,15,0.22)';
    vctx.fillRect(0,0,canvas.width,canvas.height);

    const scale = 0.004 + 0.0015*intensity;
    for(let L=0; L<3; L++){
      const alpha = 0.06 + 0.16*intensity*(1-L/3);
      vctx.globalAlpha=alpha;
      vctx.globalCompositeOperation='lighter';
      const hue = 200 + (270-200)*(0.25+0.75*intensity) + L*5;
      vctx.fillStyle = `hsla(${hue},85%,${40+L*4}%,${alpha})`;
      const step = 12 + L*4;
      for(let y=0;y<canvas.height;y+=step){
        for(let x=0;x<canvas.width;x+=step){
          const n=fbm(x*scale, y*scale, t*0.00045 + L*10);
          const r = step*(0.8 + 1.9*n*intensity);
          vctx.beginPath(); vctx.ellipse(x,y,r,r*0.7,0,0,Math.PI*2); vctx.fill();
        }
      }
    }

    const lines = 3, lineGap = 1.15;
    const catHeight = canvas.height * 0.80;
    const px = Math.max(10, Math.floor(catHeight / (lines * lineGap)));
    const lineStep = Math.floor(px * lineGap);

    catTimer += 1;
    const framePeriod = 30 + Math.floor(50*(1-intensity));
    if (catTimer >= framePeriod){ catTimer=0; catIndex=(catIndex+1)%catL.length; }
    const Lcat = catL[catIndex].split("\n");
    const Rcat = catR[catIndex].split("\n");

    vctx.globalAlpha = 0.9;
    vctx.globalCompositeOperation='source-over';
    vctx.textAlign='center';
    vctx.font = `${px}px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace`;

    const baseY = Math.floor((canvas.height - (lines-1)*lineStep - px) / 2);
    const bobL = Math.sin(t*0.002 + intensity*2.0) * (8 * (0.4+0.6*intensity));
    const bobR = Math.sin(t*0.002 + Math.PI + intensity*1.6) * (8 * (0.4+0.6*intensity));

    const sway = Math.sin(t*0.001) * (6 * (0.2+0.8*intensity));
    const cxL = Math.floor(canvas.width*0.30 + sway);
    const cxR = Math.floor(canvas.width*0.70 - sway);

    vctx.fillStyle = `rgba(103,212,255,${0.15+0.25*intensity})`;
    Lcat.forEach((line,i)=>{ vctx.fillText(line, cxL+1, baseY + i*lineStep + 1 + bobL); });
    vctx.fillStyle = `rgba(233,241,247,0.9)`;
    Lcat.forEach((line,i)=>{ vctx.fillText(line, cxL,   baseY + i*lineStep     + bobL); });

    vctx.fillStyle = `rgba(180,134,255,${0.15+0.25*intensity})`;
    Rcat.forEach((line,i)=>{ vctx.fillText(line, cxR+1, baseY + i*lineStep + 1 + bobR); });
    vctx.fillStyle = `rgba(233,241,247,0.9)`;
    Rcat.forEach((line,i)=>{ vctx.fillText(line, cxR,   baseY + i*lineStep     + bobR); });

    vctx.globalAlpha=1;
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // Meter
  function drawMeter(db){
    const w=inMeter.width,h=inMeter.height; mctx.clearRect(0,0,w,h);
    const n=Math.max(0,Math.min(1,(db+90)/90));
    mctx.fillStyle='rgba(255,255,255,.06)'; mctx.fillRect(0,0,w,h);
    mctx.fillStyle = n>0.95?'#ff6b6b':(n>0.8?'#ffcc66':'#69e089');
    mctx.fillRect(0,0,Math.floor(w*n),h);
  }

  function buildIR(ctx,dur=2.2,decay=0.4){
    const rate=ctx.sampleRate, len=Math.floor(rate*dur), buf=ctx.createBuffer(2,len,rate);
    for(let ch=0; ch<2; ch++){ const d=buf.getChannelData(ch); for(let i=0;i<len;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay*3); } }
    return buf;
  }

})();
</script>
</body>
</html>
